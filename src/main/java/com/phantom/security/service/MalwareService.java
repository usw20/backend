package com.phantom.security.service;

import com.phantom.security.dto.request.MalwareScanRequest;
import com.phantom.security.dto.response.MalwareScanResponse;
import com.phantom.security.dto.response.MalwareScanResult;
import com.phantom.security.model.MalwareScanLog;
import com.phantom.security.repository.MalwareScanLogRepository;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.http.*;
import org.springframework.stereotype.Service;
import org.springframework.web.client.RestTemplate;
import org.springframework.web.client.ResourceAccessException;
import org.springframework.web.client.HttpClientErrorException;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Map;
import java.util.HashMap;
import java.util.stream.Collectors;

@Service
public class MalwareService {

    @Autowired
    private MalwareScanLogRepository malwareScanLogRepository;

    @Autowired
    private RestTemplate restTemplate;

    @Value("${ai.malware.server.url:http://localhost:5001}")
    private String aiMalwareServerUrl;

    /**
     * 악성코드 스캔 데이터 처리 (전처리 + AI 호출 + 결과 저장)
     */
    public MalwareScanResult processScanData(String userId, MalwareScanRequest request) {
        try {
            // 1. 데이터 전처리
            Map<String, Object> preprocessedData = preprocessMalwareData(request, userId);

            // 2. AI 서버로 분석 요청
            Map<String, Object> aiResponse = callAiMalwareAnalysis(preprocessedData);

            // 3. 결과를 DB에 저장
            MalwareScanLog scanLog = createScanLogFromAiResponse(userId, request, aiResponse);
            malwareScanLogRepository.save(scanLog);

            // 4. 결과를 앱에 반환
            return createScanResult(aiResponse);

        } catch (Exception e) {
            // AI 서버 장애 시 폴백 로직
            return handleFallbackProcessing(userId, request);
        }
    }

    /**
     * 악성코드 데이터 전처리
     */
    private Map<String, Object> preprocessMalwareData(MalwareScanRequest request, String userId) {
        Map<String, Object> data = new HashMap<>();

        // 기본 정보
        data.put("package_name", request.getTargetPackageName());
        data.put("file_hash", request.getTargetHash());
        data.put("scan_type", request.getScanType());
        data.put("user_id", userId);
        data.put("device_id", request.getDeviceId());

        // 앱 권한 분석
        List<String> permissions = request.getPermissions();
        if (permissions != null) {
            data.put("permissions", permissions);
            data.put("dangerous_permissions", extractDangerousPermissions(permissions));
            data.put("permission_risk_score", calculatePermissionRiskScore(permissions));
        }

        // 파일 정보
        if (request.getFileSize() != null) {
            data.put("file_size", request.getFileSize());
            data.put("normalized_file_size", normalizeFileSize(request.getFileSize()));
        }

        // API 호출 패턴
        if (request.getApiCalls() != null) {
            data.put("api_calls", request.getApiCalls());
            data.put("suspicious_api_count", countSuspiciousApis(request.getApiCalls()));
        }

        // 설치 시간 정보
        if (request.getInstallTime() != null) {
            data.put("install_time", request.getInstallTime());
        }

        // 버전 정보
        if (request.getVersionCode() != null) {
            data.put("version_code", request.getVersionCode());
        }

        data.put("timestamp", LocalDateTime.now().toString());

        return data;
    }

    /**
     * AI 서버 호출
     */
    private Map<String, Object> callAiMalwareAnalysis(Map<String, Object> data) {
        try {
            HttpHeaders headers = new HttpHeaders();
            headers.setContentType(MediaType.APPLICATION_JSON);

            HttpEntity<Map<String, Object>> entity = new HttpEntity<>(data, headers);

            ResponseEntity<Map> response = restTemplate.exchange(
                    aiMalwareServerUrl + "/api/analyze/malware",
                    HttpMethod.POST,
                    entity,
                    Map.class
            );

            return response.getBody();

        } catch (ResourceAccessException e) {
            throw new RuntimeException("AI 서버에 연결할 수 없습니다: " + e.getMessage());
        } catch (HttpClientErrorException e) {
            throw new RuntimeException("AI 서버 요청 처리 중 오류 발생: " + e.getMessage());
        }
    }

    /**
     * AI 응답을 기반으로 스캔 로그 생성
     */
    private MalwareScanLog createScanLogFromAiResponse(String userId, MalwareScanRequest request, Map<String, Object> aiResponse) {
        MalwareScanLog scanLog = new MalwareScanLog();
        scanLog.setUserId(userId);
        scanLog.setDeviceId(request.getDeviceId());
        scanLog.setTargetPackageName(request.getTargetPackageName());
        scanLog.setTargetHash(request.getTargetHash());
        scanLog.setScanType(request.getScanType());

        // AI 분석 결과 적용
        Boolean isMalicious = (Boolean) aiResponse.get("is_malicious");
        Double confidence = ((Number) aiResponse.get("confidence")).doubleValue();

        if (isMalicious != null && isMalicious) {
            scanLog.setScanResult(confidence > 0.8 ? "malicious" : "suspicious");
            scanLog.setThreatName((String) aiResponse.get("threat_type"));
            scanLog.setIsBlocked(confidence > 0.7);
        } else {
            scanLog.setScanResult("safe");
            scanLog.setThreatName(null);
            scanLog.setIsBlocked(false);
        }

        scanLog.setDetectedAt(LocalDateTime.now());

        return scanLog;
    }

    /**
     * AI 응답을 앱 응답 형태로 변환
     */
    private MalwareScanResult createScanResult(Map<String, Object> aiResponse) {
        Boolean isMalicious = (Boolean) aiResponse.get("is_malicious");
        Double confidence = ((Number) aiResponse.get("confidence")).doubleValue();
        String threatType = (String) aiResponse.get("threat_type");

        return new MalwareScanResult(isMalicious, confidence, threatType);
    }

    /**
     * AI 서버 장애 시 폴백 탐지 로직
     */
    private MalwareScanResult handleFallbackProcessing(String userId, MalwareScanRequest request) {
        // 간단한 키워드 기반 탐지
        String packageName = request.getTargetPackageName().toLowerCase();

        String[] maliciousPatterns = {
                "malware", "virus", "trojan", "backdoor", "spyware",
                "adware", "rootkit", "evilapp", "hacktools"
        };

        boolean isMalicious = false;
        String threatType = "Unknown";
        double confidence = 0.5;

        for (String pattern : maliciousPatterns) {
            if (packageName.contains(pattern)) {
                isMalicious = true;
                threatType = "Malware.Android." + pattern.substring(0, 1).toUpperCase() + pattern.substring(1);
                confidence = 0.6;
                break;
            }
        }

        // 폴백 결과도 DB에 저장
        MalwareScanLog scanLog = new MalwareScanLog(
                userId, request.getDeviceId(), request.getScanType(),
                request.getTargetPackageName(), request.getTargetHash()
        );
        scanLog.setScanResult(isMalicious ? "suspicious" : "safe");
        scanLog.setThreatName(isMalicious ? threatType : null);
        scanLog.setIsBlocked(false);
        scanLog.setDetectedAt(LocalDateTime.now());

        malwareScanLogRepository.save(scanLog);

        return new MalwareScanResult(isMalicious, confidence, threatType);
    }

    /**
     * 사용자별 악성코드 탐지 이력 조회
     */
    public List<MalwareScanResponse> getMalwareHistory(String userId) {
        List<MalwareScanLog> logs = malwareScanLogRepository.findByUserIdOrderByDetectedAtDesc(userId);

        return logs.stream()
                .map(MalwareScanResponse::new)
                .collect(Collectors.toList());
    }

    /**
     * 위험 권한 추출
     */
    private List<String> extractDangerousPermissions(List<String> permissions) {
        List<String> dangerousPermissions = List.of(
                "android.permission.READ_SMS",
                "android.permission.SEND_SMS",
                "android.permission.CALL_PHONE",
                "android.permission.ACCESS_FINE_LOCATION",
                "android.permission.CAMERA",
                "android.permission.RECORD_AUDIO",
                "android.permission.READ_CONTACTS",
                "android.permission.WRITE_EXTERNAL_STORAGE",
                "android.permission.SYSTEM_ALERT_WINDOW"
        );

        return permissions.stream()
                .filter(dangerousPermissions::contains)
                .collect(Collectors.toList());
    }

    /**
     * 권한 위험도 점수 계산
     */
    private double calculatePermissionRiskScore(List<String> permissions) {
        Map<String, Double> riskWeights = Map.of(
                "android.permission.READ_SMS", 0.9,
                "android.permission.SEND_SMS", 0.9,
                "android.permission.CALL_PHONE", 0.8,
                "android.permission.ACCESS_FINE_LOCATION", 0.7,
                "android.permission.CAMERA", 0.6,
                "android.permission.RECORD_AUDIO", 0.8
        );

        return permissions.stream()
                .mapToDouble(perm -> riskWeights.getOrDefault(perm, 0.1))
                .sum();
    }

    /**
     * 파일 크기 정규화
     */
    private double normalizeFileSize(Long fileSize) {
        if (fileSize == null) return 0.0;
        // MB 단위로 변환하고 로그 스케일 적용
        return Math.log(fileSize / 1024.0 / 1024.0 + 1);
    }

    /**
     * 의심스러운 API 호출 수 계산
     */
    private int countSuspiciousApis(List<String> apiCalls) {
        List<String> suspiciousApis = List.of(
                "Runtime.exec",
                "ProcessBuilder",
                "System.loadLibrary",
                "Class.forName",
                "Method.invoke"
        );

        return (int) apiCalls.stream()
                .filter(suspiciousApis::contains)
                .count();
    }

    /**
     * 악성코드 탐지 통계
     */
    public Map<String, Long> getMalwareStatistics(String userId) {
        return Map.of(
                "total", malwareScanLogRepository.countByUserId(userId),
                "malicious", malwareScanLogRepository.countByUserIdAndScanResult(userId, "malicious"),
                "suspicious", malwareScanLogRepository.countByUserIdAndScanResult(userId, "suspicious"),
                "safe", malwareScanLogRepository.countByUserIdAndScanResult(userId, "safe")
        );
    }
}